//
//  main.swift
//  USDConverter
//
//  Created by Emma Alyx Wunder on 11.06.19.
//  Copyright © 2019 Emma Alyx Wunder. All rights reserved.
//

import Foundation
import ModelIO

extension Sequence where Iterator.Element: Hashable {
    func unique() -> [Iterator.Element] {
        var seen: [Iterator.Element: Bool] = [:]
        return self.filter { seen.updateValue(true, forKey: $0) == nil }
    }
}

let version = "1.2.1"
print("usdconv v\(version)")

var inputFilePaths = CommandLine.arguments.dropFirst().unique()
var convertToPNG = false

if inputFilePaths.contains("--png") {
	convertToPNG = true
	inputFilePaths.removeAll(where: { $0 == "--png" })
	print("--png specified, will save all textures as PNG, even non-PNG ones")
}

guard inputFilePaths.count != 0 else {
	print("You need to specify at least one file to convert.")
	exit(1)
}


for inFile in inputFilePaths {
	let model = URL(fileURLWithPath: inFile)
	let modelExt = model.pathExtension.lowercased()

	guard modelExt == "usdz", MDLAsset.canImportFileExtension(modelExt) else {
		print("Error opening \(model.lastPathComponent): usdconf can only open USDZ files.")
		continue
	}

	let modelDir = model.deletingLastPathComponent()
	let modelBase = model.deletingPathExtension().lastPathComponent

	let modelOut   = "\(modelBase).obj"
	let modelMtl   = "\(modelBase).mtl"
	let modelIOMtl = "\(modelBase)_ModelIO.mtl"
	let modelInfo  = "\(modelBase)_duplicates.txt"

	let asset = MDLAsset(url: model)

	// MARK: - Converting USDZ to OBJ and generating Model I/O MTL file

	print("Converting \(model.lastPathComponent)…")
	let modelOutURL = URL(fileURLWithPath: modelOut, relativeTo: modelDir)

	do {
		try asset.export(to: modelOutURL)
	} catch {
		print("Couldn't convert \(model.lastPathComponent).")
		continue
	}

	// MARK: - Renaming MTL file generated by Model I/O

	print("Renaming ModelIO MTL file…")
	let mtlURL = URL(fileURLWithPath: modelMtl, relativeTo: modelDir)
	let modelIOURL = URL(fileURLWithPath: modelIOMtl, relativeTo: modelDir)

	do {
		try FileManager.default.removeItem(at: modelIOURL)
	} catch { /* Silently catch this because the file at modelIOURL might not exist */ }

	do {
		try FileManager.default.moveItem(at: mtlURL, to: modelIOURL)
	} catch {
		print("Couldn't rename \(modelMtl) to \(modelIOMtl)")
		continue
	}

	// MARK: - Generating better MTL file

	print("Generating MTL file: \(mtlURL.lastPathComponent)…")
	let modelFile = try ModelFile(modelFile: model)
	let mtlContent = modelFile.generateMTL(convertToPNG)
	do {
		try mtlContent.write(to: mtlURL, atomically: false, encoding: .utf8)
	} catch {
		print("Couldn't write \(modelMtl)")
		continue
	}

	// MARK: - Generating list of duplicate materials

	let materialsURL = URL(fileURLWithPath: modelInfo, relativeTo: modelDir)
	print("Generating list of duplicate materials: \(materialsURL.lastPathComponent)…")

	let materialCountDict = Dictionary(grouping: modelFile.materials, by: { $0 })
	let sortedMaterialCount = materialCountDict.sorted(by: {$0.1.count > $1.1.count})

	var auxString = "# USDConverter List Of Duplicate Materials: \(modelOut)\n"

	auxString.append("\(sortedMaterialCount.count) distinct materials in total\n\n")

	for kvi in sortedMaterialCount {
		let occurrenceStr = kvi.value.count == 1 ? "occurrence" : "occurrences"
		auxString.append("\(kvi.value.count) \(occurrenceStr): \(kvi.key.name)\n")

		for material in kvi.value.sorted(by: { $0.name.localizedStandardCompare($1.name) == .orderedAscending }) {
			auxString.append("\t\(material.name)\n")
		}
		auxString.append("\n")
	}

	do {
		let outputStr = auxString.trimmingCharacters(in: .whitespacesAndNewlines)
		try outputStr.write(to: materialsURL, atomically: false, encoding: .utf8)
	} catch {
		print("Couldn't write \(modelInfo)")
		continue
	}

	// MARK: - Extracting and optionally re-encoding textures

	print("Extracting textures…")
	if !modelFile.extractTextures(convertToPNG) {
		print("Couldn't extract textures")
	}

	print("Exported \(model.lastPathComponent) to \(modelOutURL.lastPathComponent)")
}

print("Done.")
